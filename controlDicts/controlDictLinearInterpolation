/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  7
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    location    "system";
    object      controlDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

application     chtMultiRegionFoam;

startFrom       startTime;

startTime       0;

stopAt          endTime;

endTime         40;

deltaT          0.01;

writeControl    adjustableRunTime;

writeInterval   1;

purgeWrite      0;

writeFormat     binary;

writePrecision  6;

writeCompression off;

timeFormat      general;

timePrecision   6;

runTimeModifiable false;

maxCo           0.5;

maxDi           10.0;

adjustTimeStep  no;

functions
{

    multiRegion
    {
        type            multiRegion;
        libs ("libutilityFunctionObjects.so");

        function
        {
            // Actual object specification
            libs ("libutilityFunctionObjects.so");
        type coded;
        name MUICoupling;
        writeControl timeStep;

	
        codeInclude
        #{
                #include        "../../../MUI-2.0/include/mui.h"
                #include        "../../system/muiconfig.h"
                #include        "mpi.h"
                #include        "mixedFvPatchField.H"
                #include  "mixedFvPatchField.H"
        #};
            
        codeOptions
        #{
                -I/usr/lib/x86_64-linux-gnu/openmpi/include -w
        #};
        
        codeLibs
        #{
                -L/usr/lib/x86_64-linux-gnu -lmpi -lmpi_cxx -w
        #};
            ///////////////////////////////////////////////////////////////////////////////
            //////// declare the variable that will be used by the functions. It is called once at the start /////////////
            
            
        codeData
        #{
                bool setup = true;
                std::vector<std::unique_ptr<mui::uniface<mui::mui_config>>> mui_ifs;
                mui::point1d push_point;
                mui::sampler_exact<mui::mui_config> spatial_sampler;
                mui::temporal_sampler_exact<mui::mui_config> temporal_sampler;
    
                int rank;
                double nodesY = 0;
                double valueFrac;
        #};
            
            ///////////////////////////////////////////////////////////////////////////////
            /// Every time step this part is called ////////////////
        codeRead
        #{
           if (setup) 
            {
                MPI_Comm_rank(MPI_COMM_WORLD, &rank);
                Info << "OF says hello from rank " << rank << "\n";
                std::vector<std::string> ifsName;
                ifsName.emplace_back("ifs" + std::to_string(rank+1));
                mui_ifs=mui::create_uniface<mui::mui_config>( "OpenFOAM", ifsName );	    
                Info <<  "OF solver Finsihed creating MUI interface " << endl; 
                
                scalar dt = mesh().time().deltaTValue();

                Info << "DT before: " << dt << endl;
            
                MPI_Allreduce(&dt, &dt, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);

                Time& runTime = const_cast<Time&>(mesh().time());
                
                runTime.setDeltaT(dt, false);

                Info << "nodesY: "<< nodesY << " MinDT:" << dt << endl;  


            }

        #};
        
        codeExecute
        #{
            //Access temperature field 
            volScalarField& T = const_cast<volScalarField&>(mesh().lookupObject<volScalarField>("T"));
            const label patch = mesh().boundaryMesh().findPatchID("rightWall");
            fvPatchField<scalar>& Tp = const_cast<fvPatchField<scalar>&>(T.boundaryField()[patch]);

            // access internalField of cells at boundary
            scalarField internal = Tp.patchInternalField();
            Info << internal << endl;
            Info << Tp << endl;
            Info << mesh().boundary()[patch].deltaCoeffs() << endl;           
            // push those values to MUI for coupling condition
            forAll(internal, faceI){
                 push_point[0] = faceI;
                 mui_ifs[0]->push( "flux", push_point, internal[faceI]);
            }
                   
            push_point[0] = 0;
            double kDelta = 318*mesh().boundary()[patch].deltaCoeffs()[0];
            mui_ifs[0]->push( "weight", push_point, kDelta);
            mui_ifs[0]->commit(0);

            valueFrac = 1 - (kDelta)/(mui_ifs[0]->fetch_values<mui::mui_config::REAL>( "weight", 0, temporal_sampler )[0]+kDelta);
            Info << "Value Frac: " << valueFrac << endl;
            setup = false;

            // commit the temperature values for this timestep, this is the cue for ping to fetch values.
            double time =  mesh().time().value();            
            mui_ifs[0]->commit( time ); 
        
            
            std::vector<double> fetch_vals = mui_ifs[0]->fetch_values<mui::mui_config::REAL>( "temp", time, temporal_sampler );


            mixedFvPatchField<scalar>& mixedPf = refCast<mixedFvPatchField<scalar>>(Tp);

            mixedPf.refValue() = scalarField(mixedPf.size(), fetch_vals[5]);

            mixedPf.valueFraction() = scalarField(mixedPf.size(), valueFrac);

            mixedPf.refGrad() = scalarField(mixedPf.size(), 0);


            mixedPf.updateCoeffs();
            
            Info<<"Average T at rightWall: " <<  average(Tp) << endl;
        
            mui_ifs[0]->forget(time);
        
        #};
    }

        // Optional entries
        regions         (right);
    }
}