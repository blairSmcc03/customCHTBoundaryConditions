/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  7
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    location    "system";
    object      controlDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

application     chtMultiRegionFoam;

startFrom       startTime;

startTime       0;

stopAt          endTime;

endTime         40;

deltaT          0.01;

writeControl    adjustableRunTime;

writeInterval   1;

purgeWrite      0;

writeFormat     binary;

writePrecision  6;

writeCompression off;

timeFormat      general;

timePrecision   6;

runTimeModifiable false;

maxCo           0.5;

maxDi           10.0;

adjustTimeStep  no;

libs ("libcustomCoupledBoundary.so");

/* cht
functions
{

    multiRegion
    {
        type            multiRegion;
        libs ("libutilityFunctionObjects.so");

        function
        {
            // Actual object specification
            libs ("libutilityFunctionObjects.so");
        type coded;
        name MUICoupling;
        writeControl timeStep;

	
        codeInclude
        #{
                #include        "../../../MUI-2.0/include/mui.h"
                #include        "../../system/muiconfig.h"
                #include        "mpi.h"
                #include        "mixedFvPatchField.H"
                #include  "mixedFvPatchField.H"
        #};
            
        codeOptions
        #{
                -I/usr/lib/x86_64-linux-gnu/openmpi/include -w
        #};
        
        codeLibs
        #{
                -L/usr/lib/x86_64-linux-gnu -lmpi -lmpi_cxx -w
        #};
            ///////////////////////////////////////////////////////////////////////////////
            //////// declare the variable that will be used by the functions. It is called once at the start /////////////
            
            
        codeData
        #{
                bool setup = true;
                std::vector<std::unique_ptr<mui::uniface<mui::mui_config>>> mui_ifs;
                mui::point1d push_point;
                mui::sampler_exact<mui::mui_config> spatial_sampler;
                mui::temporal_sampler_exact<mui::mui_config> temporal_sampler;
    
                int rank;
                double nodesY = 0;
                double valueFrac;
        #};
            
            ///////////////////////////////////////////////////////////////////////////////
            /// Every time step this part is called ////////////////
        codeRead
        #{
           if (setup) 
            {
                MPI_Comm_rank(MPI_COMM_WORLD, &rank);
                Info << "OF says hello from rank " << rank << "\n";
                std::vector<std::string> ifsName;
                ifsName.emplace_back("ifs" + std::to_string(rank+1));
                mui_ifs=mui::create_uniface<mui::mui_config>( "OpenFOAM", ifsName );	    
                Info <<  "OF solver Finsihed creating MUI interface " << endl; 

                
                //const Time& runTime = mesh().time();
                //Info << runTime.deltaTValue() << endl;
        
                volScalarField& T = const_cast<volScalarField&>(mesh().lookupObject<volScalarField>("T"));
                const label patch = mesh().boundaryMesh().findPatchID("rightWall");

                forAll(T.boundaryField()[patch], i){
                    nodesY++;
                }
                
                scalar dt = mesh().time().deltaTValue();

                Info << "DT before: " << dt << endl;
            
                MPI_Allreduce(&dt, &dt, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);

                Time& runTime = const_cast<Time&>(mesh().time());
                
                runTime.setDeltaT(dt, false);

                Info << "nodesY: "<< nodesY << " MinDT:" << dt << endl;  

                push_point[0] = rank;
                double kDelta = 318*mesh().boundary()[patch].deltaCoeffs()[0];
                mui_ifs[0]->push( "weight", push_point, kDelta);
                mui_ifs[0]->commit(0);

                valueFrac = 1 - (kDelta)/(mui_ifs[0]->fetch_values<mui::mui_config::REAL>( "weight", 0, temporal_sampler )[0]+kDelta);
                Info << "Value Frac: " << valueFrac << endl;
                setup = false;

            }

        #};
        
        codeExecute
        #{
            //Access temperature field 
            volScalarField& T = const_cast<volScalarField&>(mesh().lookupObject<volScalarField>("T"));
            const label patch = mesh().boundaryMesh().findPatchID("rightWall");
            fvPatchField<scalar>& Tp = const_cast<fvPatchField<scalar>&>(T.boundaryField()[patch]);

            // access internalField of cells at boundary
            scalarField internal = Tp.patchInternalField();
            Info << internal << endl;
            Info << Tp << endl;
            Info << mesh().boundary()[patch].deltaCoeffs() << endl;           
            // push those values to MUI for coupling condition
            forAll(internal, faceI){
                 push_point[0] = faceI;
                 mui_ifs[0]->push( "flux", push_point, internal[faceI]);
            }
                   
            // commit the temperature values for this timestep, this is the cue for ping to fetch values.
            double time =  mesh().time().value();            
            mui_ifs[0]->commit( time ); 
        
            
            std::vector<double> fetch_vals = mui_ifs[0]->fetch_values<mui::mui_config::REAL>( "temp", time, temporal_sampler );


            mixedFvPatchField<scalar>& mixedPf = refCast<mixedFvPatchField<scalar>>(Tp);

            mixedPf.refValue() = scalarField(mixedPf.size(), fetch_vals[5]);

            mixedPf.valueFraction() = scalarField(mixedPf.size(), valueFrac);

            mixedPf.refGrad() = scalarField(mixedPf.size(), 0);


            mixedPf.updateCoeffs();
            
            Info<<"Average T at rightWall: " <<  average(Tp) << endl;
        
            mui_ifs[0]->forget(time);
        
        #};
    }

        // Optional entries
        regions         (right);
    }
}
*/
/*
functions
{

    multiRegion
    {
        type            multiRegion;
        libs ("libutilityFunctionObjects.so");

        function
        {
            // Actual object specification
        libs ("libutilityFunctionObjects.so");
        type coded;
        name MUICoupling;
        writeControl timeStep;

	
        codeInclude
        #{
                #include        "../../../MUI-2.0/include/mui.h"
                #include        "../../system/muiconfig.h"
                #include        "mpi.h"
                #include        "mixedFvPatchField.H"
                #include  "mixedFvPatchField.H"
        #};
            
        codeOptions
        #{
                -I/usr/lib/x86_64-linux-gnu/openmpi/include -w
        #};
        
        codeLibs
        #{
                -L/usr/lib/x86_64-linux-gnu -lmpi -lmpi_cxx -w
        #};
            ///////////////////////////////////////////////////////////////////////////////
            //////// declare the variable that will be used by the functions. It is called once at the start /////////////
            
            
        codeData
        #{
                bool setup = true;
                std::vector<std::unique_ptr<mui::uniface<mui::mui_config>>> mui_ifs;
                mui::point1d push_point;
                mui::sampler_exact<mui::mui_config> spatial_sampler;
                mui::temporal_sampler_exact<mui::mui_config> temporal_sampler;
    
                int rank;
                double nodesY = 0;
                bool dirichBoundary;
                double kappa = 318;
        #};

            
            ///////////////////////////////////////////////////////////////////////////////
            /// Every time step this part is called ////////////////
        codeRead
        #{
           if (setup) 
            {
                MPI_Comm_rank(MPI_COMM_WORLD, &rank);
                Info << "OF says hello from rank " << rank << "\n";
                std::vector<std::string> ifsName;
                ifsName.emplace_back("ifs" + std::to_string(rank+1));
                mui_ifs=mui::create_uniface<mui::mui_config>( "OpenFOAM", ifsName );	    
                Info <<  "OF solver Finsihed creating MUI interface " << endl; 

                
                //const Time& runTime = mesh().time();
                //Info << runTime.deltaTValue() << endl;
        
                volScalarField& T = const_cast<volScalarField&>(mesh().lookupObject<volScalarField>("T"));
                const label patch = mesh().boundaryMesh().findPatchID("rightWall");

                forAll(T.boundaryField()[patch], i){
                    nodesY++;
                }
                
                scalar dt = mesh().time().deltaTValue();

                Info << "DT before: " << dt << endl;
            
                MPI_Allreduce(&dt, &dt, 1, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);

                Time& runTime = const_cast<Time&>(mesh().time());
                
                runTime.setDeltaT(dt, false);

                Info << "nodesY: "<< nodesY << " MinDT:" << dt << endl;  

                push_point[0] = rank;
                double c = 1*kappa*mesh().boundary()[patch].deltaCoeffs()[0];
                mui_ifs[0]->push( "coupling", push_point, c);
                mui_ifs[0]->commit(0);

                std::vector<double> fetch_vals = mui_ifs[0]->fetch_values<mui::mui_config::REAL>( "coupling", 0, temporal_sampler );

                c = c / fetch_vals[0];
                if(c <= 1){
                    dirichBoundary = true;
                }else{
                    dirichBoundary = false;
                }
                Info << "dirichBoundary: " << dirichBoundary << endl;
                setup = false;

            }

        #};
        
        codeExecute
        #{
            //Access temperature field 
            volScalarField& T = const_cast<volScalarField&>(mesh().lookupObject<volScalarField>("T"));
            const label patch = mesh().boundaryMesh().findPatchID("rightWall");
            fvPatchField<scalar>& Tp = const_cast<fvPatchField<scalar>&>(T.boundaryField()[patch]);
            mixedFvPatchField<scalar>& mixedPf = refCast<mixedFvPatchField<scalar>>(Tp);
            scalarField internal = Tp.patchInternalField();
            // access internalField of cells at boundary
           
            double time =  mesh().time().value();            

            if(dirichBoundary){
                //Calcualate heat flux (
                //scalar Q = gSum(kappaTp*patch().magSf()*snGrad());
                scalar Q;
                
                scalarField flux = (Tp-internal)*mesh().boundary()[patch].deltaCoeffs();
                flux = flux * kappa * mesh().boundary()[patch].magSf()*100;
                
                // push flux
               forAll(Tp, faceI){
                    push_point[0] = faceI;
                    mui_ifs[0]->push( "flux", push_point, flux[faceI]*nodesY);
                }
                mui_ifs[0]->commit( time ); 
                //fetch temperature
                std::vector<double> fetch_vals = mui_ifs[0]->fetch_values<mui::mui_config::REAL>( "temp", time, temporal_sampler );

                //enforce fixed value bc
                mixedPf.refValue() = scalarField(mixedPf.size(), fetch_vals[0]);
                mixedPf.valueFraction() = scalarField(mixedPf.size(), 1);
                mixedPf.updateCoeffs();
    
            }else{
                //push boundary temp
                forAll(Tp, faceI){
                    push_point[0] = faceI;
                    mui_ifs[0]->push( "flux", push_point, Tp[faceI]);
                }
                mui_ifs[0]->commit( time ); 

                //Fetch heatflux
                std::vector<double> fetch_vals = mui_ifs[0]->fetch_values<mui::mui_config::REAL>( "flux", time, temporal_sampler );
                Info << Tp << endl;
                //set boundary value based on heat flux
                scalarField newTemp = scalarField(mixedPf.size(), fetch_vals[0]/(nodesY*kappa*100));
                Info << newTemp << endl;
                newTemp = internal - (newTemp / (mesh().boundary()[patch].deltaCoeffs()*mesh().boundary()[patch].magSf()));

                mixedPf.refValue() = newTemp;
                mixedPf.valueFraction() = scalarField(mixedPf.size(), 1);
                mixedPf.updateCoeffs();
            }       
        
            Info<<"Average T at rightWall: " <<  average(Tp) << endl;
        
            mui_ifs[0]->forget(time);
        
        #};
    }

        // Optional entries
        regions         (right);
    }
}
*/